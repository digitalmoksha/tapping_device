class TappingDevice
  module SqlTappingMethods
    CALL_STACK_SKIPPABLE_METHODS = [:transaction, :tap]

    # SQLListener acts like an interface for us to intercept activerecord query instrumentations
    # this means we only need to register one subscriber no matter how many objects we want to tap on
    class SQLListener
      def call(name, start, finish, message_id, values);end
    end
    @@sql_listener = SQLListener.new

    ActiveSupport::Notifications.subscribe("sql.active_record", @@sql_listener)

    def tap_sql!(object)
      @call_stack = []
      @target ||= object
      @trace_point = with_trace_point_on_target(object, event: [:call, :c_call]) do |start_tp|
        ########## Check if the call is worth recording ##########
        filepath, line_number = get_call_location(start_tp, padding: 1) # we need extra padding because of `with_trace_point_on_target`
        method = start_tp.callee_id
        next if should_be_skipped_by_paths?(filepath) || already_recording?(method)

        ########## Start the recording ##########
        # 1. Mark recording state by pushing method into @call_stack
        # 2. Subscribe sql instrumentations generated by activerecord
        # 3. Record those sqls and run device callbacks
        # 4. Start waiting for current call's return callback
        @call_stack.push(method)
        payload = build_payload(tp: start_tp, filepath: filepath, line_number: line_number)
        device = tap_on_sql_instrumentation!(payload)

        with_trace_point_on_target(object, event: :return) do |return_tp|
          next unless return_tp.callee_id == method

          ########## End recording ##########
          # 1. Close itself
          # 2. Stop our subscription on SQLListener
          # 3. Remove current method from @call_stack
          # 4. Stop the device if stop condition is fulfilled
          return_tp.disable
          device.stop!
          @call_stack.pop
          stop_if_condition_fulfilled(payload)

          ########## Track descendant objects ##########
          # if the method creates another Relation object
          if return_tp.defined_class == ActiveRecord::QueryMethods
            create_child_device.tap_sql!(return_tp.return_value)
          end
        end.enable
      end

      @trace_point.enable unless self.class.suspend_new

      self
    end
  end

  private

  def tap_on_sql_instrumentation!(payload)
    device = TappingDevice.new do |sql_listener_payload|
      values = sql_listener_payload.arguments[:values]

      next if ["SCHEMA", "TRANSACTION"].include? values[:name]
      next if values[:sql].match?(/SAVEPOINT/)

      payload[:sql] = values[:sql]
      record_call!(payload)
    end
    device.tap_on!(@@sql_listener)
  end

  # usually, AR's query methods (like `first`) will end up calling `find_by_sql`
  # then to TappingDevice, both `first` and `find_by_sql` generates the sql
  # but the results are duplicated, we should only consider the `first` call
  def already_recording?(method)
    !@call_stack.empty? || CALL_STACK_SKIPPABLE_METHODS.include?(method)
  end

  def with_trace_point_on_target(object, event:)
    TracePoint.new(*event) do |tp|
      if is_from_target?(object, tp)
        yield(tp)
      end
    end
  end
end
